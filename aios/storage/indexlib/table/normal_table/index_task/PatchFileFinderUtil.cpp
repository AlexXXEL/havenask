/*
 * Copyright 2014-present Alibaba Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include "indexlib/table/normal_table/index_task/PatchFileFinderUtil.h"

#include "indexlib/base/PathUtil.h"
#include "indexlib/file_system/IDirectory.h"
#include "indexlib/framework/TabletData.h"
#include "indexlib/index/common/patch/SrcDestPatchFileFinder.h"
#include "indexlib/table/index_task/IndexTaskConstant.h"
#include "indexlib/table/normal_table/index_task/Common.h"

namespace indexlibv2::table {
AUTIL_LOG_SETUP(indexlib.table, PatchFileFinderUtil);

// TODO: Find OpLog2Patch dependent op id, (maybe from opDesc that is set in CommonTaskOperationCreator)
// Return valid OpLog2PatchRootDir if should load patches from OpLog2Patch directory.
std::pair<Status, std::shared_ptr<indexlib::file_system::IDirectory>>
PatchFileFinderUtil::GetOpLog2PatchRootDir(const framework::IndexOperationDescription& desc,
                                           const framework::IndexTaskContext& context)
{
    framework::IndexOperationId opLog2PatchOperationId;
    if (!desc.GetParameter(DEPENDENT_OPERATION_ID, opLog2PatchOperationId)) {
        return {Status::OK(), nullptr};
    }
    std::shared_ptr<indexlib::file_system::IDirectory> opLog2PatchOpRootDir =
        context.GetDependOperationFenceRoot(opLog2PatchOperationId);
    if (opLog2PatchOpRootDir == nullptr) {
        auto status = Status::Corruption("get op log to patch dir failed op id [%ld]", opLog2PatchOperationId);
        AUTIL_LOG(ERROR, "%s", status.ToString().c_str());
        return {status, nullptr};
    }
    return {Status::OK(), opLog2PatchOpRootDir};
}

Status
PatchFileFinderUtil::FindPatchInfos(const indexlibv2::index::SrcDestPatchFileFinder* patchFileFinder,
                                    const std::shared_ptr<framework::TabletData>& tabletData,
                                    const std::shared_ptr<config::IIndexConfig>& indexConfig,
                                    const std::shared_ptr<indexlib::file_system::IDirectory>& opLog2PatchOpRootDir,
                                    indexlibv2::index::PatchInfos* allPatchInfos)
{
    std::vector<std::shared_ptr<framework::Segment>> segments;
    std::set<segmentid_t> segmentIdSet;
    for (const auto& segment : tabletData->CreateSlice()) {
        segments.push_back(segment);
        segmentIdSet.insert(segment->GetSegmentId());
    }
    RETURN_STATUS_DIRECTLY_IF_ERROR(
        FindPatchInfos(patchFileFinder, segments, indexConfig, opLog2PatchOpRootDir, allPatchInfos));
    std::vector<segmentid_t> uselessSegmentPatches;
    for (auto iter = allPatchInfos->begin(); iter != allPatchInfos->end(); iter++) {
        if (segmentIdSet.find(iter->first) == segmentIdSet.end()) {
            uselessSegmentPatches.push_back(iter->first);
        }
    }
    for (auto uselessSegId : uselessSegmentPatches) {
        allPatchInfos->erase(uselessSegId);
    }
    return Status::OK();
}

// Find all patches for AttributeMerger, including patches that are generated by OpLog2Patch operation, and patches from
// merged segments.
Status
PatchFileFinderUtil::FindPatchInfos(const index::SrcDestPatchFileFinder* patchFinder,
                                    const std::vector<std::shared_ptr<framework::Segment>>& srcSegments,
                                    const std::shared_ptr<config::IIndexConfig>& indexConfig,
                                    const std::shared_ptr<indexlib::file_system::IDirectory>& opLog2PatchOpRootDir,
                                    indexlibv2::index::PatchInfos* allPatchInfos)
{
    RETURN_STATUS_DIRECTLY_IF_ERROR(patchFinder->FindAllPatchFiles(srcSegments, indexConfig, allPatchInfos));

    RETURN_STATUS_DIRECTLY_IF_ERROR(
        FindPatchesFromOpLog2Patch(patchFinder, opLog2PatchOpRootDir, indexConfig, allPatchInfos));

    return Status::OK();
}

Status PatchFileFinderUtil::FindPatchesFromOpLog2Patch(
    const index::SrcDestPatchFileFinder* patchFinder,
    const std::shared_ptr<indexlib::file_system::IDirectory>& opLog2PatchOpRootDir,
    const std::shared_ptr<config::IIndexConfig>& indexConfig, indexlibv2::index::PatchInfos* allPatchInfos)
{
    if (opLog2PatchOpRootDir == nullptr) {
        return Status::OK();
    }
    auto fsResult = opLog2PatchOpRootDir->GetDirectory(OPERATION_LOG_TO_PATCH_WORK_DIR);
    if (fsResult.Code() == indexlib::file_system::ErrorCode::FSEC_NOENT) {
        return Status::OK();
    }
    auto [status, opLog2PatchWorkDir] = fsResult.StatusWith();
    RETURN_IF_STATUS_ERROR(status, "Get work dir operation_log_to_patch_work_dir from root dir[%s] failed",
                           opLog2PatchOpRootDir->GetPhysicalPath("").c_str());
    auto [existStatus, isExist] = opLog2PatchWorkDir->IsExist(OPERATION_LOG_TO_PATCH_META_FILE_NAME).StatusWith();
    RETURN_STATUS_DIRECTLY_IF_ERROR(existStatus);
    auto [archiveStatus, opLog2PatchArchiveDir] = opLog2PatchWorkDir->CreateArchiveDirectory("").StatusWith();
    RETURN_IF_STATUS_ERROR(archiveStatus, "Create operation_log_to_patch_work_dir archive dir [%s] failed",
                           opLog2PatchOpRootDir->GetPhysicalPath("").c_str());
    if (isExist) {
        RETURN_STATUS_DIRECTLY_IF_ERROR(LoadFromMetaFile(opLog2PatchOpRootDir, opLog2PatchArchiveDir, allPatchInfos));
    } else {
        auto [status, indexDir] = patchFinder->GetIndexDirectory(opLog2PatchArchiveDir, indexConfig);
        RETURN_STATUS_DIRECTLY_IF_ERROR(status);
        if (indexDir == nullptr) {
            return Status::OK();
        }
        RETURN_STATUS_DIRECTLY_IF_ERROR(patchFinder->FindPatchFiles(indexDir, INVALID_SEGMENTID, allPatchInfos));
    }
    return Status::OK();
}

Status
PatchFileFinderUtil::LoadFromMetaFile(const std::shared_ptr<indexlib::file_system::IDirectory>& opLog2PatchRootDir,
                                      const std::shared_ptr<indexlib::file_system::IDirectory>& opLog2PatchWorkDir,
                                      indexlibv2::index::PatchInfos* allPatchInfos)
{
    index::PatchFileInfos patchFileInfosFromMeta;
    AUTIL_LOG(INFO, "Load from meta file, work dir[%s]", opLog2PatchWorkDir->GetPhysicalPath("").c_str());
    if (!index::PatchFileInfos::Load(opLog2PatchWorkDir, OPERATION_LOG_TO_PATCH_META_FILE_NAME,
                                     &patchFileInfosFromMeta)) {
        auto status = Status::Corruption("load file [%s] failed, path [%s]", OPERATION_LOG_TO_PATCH_META_FILE_NAME,
                                         opLog2PatchWorkDir->GetLogicalPath().c_str());
        AUTIL_LOG(ERROR, "%s", status.ToString().c_str());
        return status;
    }
    for (const index::PatchFileInfo& patchFileInfoFromMeta : patchFileInfosFromMeta.GetPatchFileInfos()) {
        std::string patchDirectoryName = PathUtil::GetDirName(patchFileInfoFromMeta.patchFullPath);
        std::string patchFileName = PathUtil::GetFileNameFromPath(patchFileInfoFromMeta.patchFullPath);
        auto [status, patchDirectory] = opLog2PatchRootDir->GetDirectory(patchDirectoryName).StatusWith();
        RETURN_STATUS_DIRECTLY_IF_ERROR(status);
        const segmentid_t targetSegmentId = patchFileInfoFromMeta.destSegment;
        index::PatchFileInfo patchFileInfo(patchFileInfoFromMeta.srcSegment, targetSegmentId, patchDirectory,
                                           patchFileName);
        if (allPatchInfos->find(targetSegmentId) == allPatchInfos->end()) {
            index::PatchFileInfos patchFileInfos;
            patchFileInfos.SetPatchFileInfos({patchFileInfo});
            allPatchInfos->insert(std::make_pair(targetSegmentId, std::move(patchFileInfos)));
        } else {
            allPatchInfos->at(targetSegmentId).PushBack(patchFileInfo);
        }
    }
    return Status::OK();
}

} // namespace indexlibv2::table
